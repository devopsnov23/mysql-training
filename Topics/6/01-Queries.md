## Subqueries and Data Modelling 

### How do Subqueries work?

Using the IN operator a SELECT statement can be constructed to see if a column values matches what is in a specified list...  
```
SELECT lastname, firstname, state
FROM author
WHERE state IN ('IL', 'UT', 'MI')
ORDER BY 1, 2, 3;
```

The values in the list can be generated by another SELECT statement instead of keyed in directly to the statement.  

If I want to find all authors who live in states where a publisher is based I could first look up the distinct states in the publisher table, 'CA' and 'NY' and then use this...  
```
SELECT lastname, firstname, state
FROM author
WHERE state IN ('CA', 'NY')
ORDER BY 1, 2, 3;
```

...Or I could replace the list with another SELECT statement like so...  
```
SELECT lastname, firstname, state
FROM author
WHERE state IN
	(SELECT DISTINCT state FROM publisher)
ORDER BY 1, 2, 3;
```

The list of DISTINCT states in the publisher table could change (in the real world) if we added another publisher to the table from a different state.  

Conceptually, subqueries can be nested as deep as you want. In most cases, a subquery statement is processed from the bottom-up.  
The deepest nested SELECT statement sends values up to the next SELECT statement which again sends value up to the next SELECT, etc.  

It is important to remember that the values generated by a SQL statement must match the kind of value being compared to the left of the IN operator.  

This would be a mistake...  
```
SELECT lastname, firstname, state
FROM author
WHERE city IN
	(SELECT DISTINCT state FROM publisher)
ORDER BY 1, 2, 3;
```
Because I am comparing the city column to a generated list of states. This does not make logical sense.  

Also, you must compare one column to a list of values generated from one column.  

This would be a mistake...  
```
SELECT lastname, firstname, state
FROM author
WHERE city IN
	(SELECT city, state FROM publisher)
ORDER BY 1, 2, 3;
```

... because the inner query has generated a list of cities and states that the statement is comparing to city value alone.  

### Subqueries with the IN operator 
The IN operator will always compare the values for equality against value of the column specified.  

Here is how to generally format a subquery...
```
SELECT lastname, firstname, 'wrote more than one book'
FROM author
WHERE author_id IN
  (SELECT DISTINCT author_id
   FROM bookauthor
   GROUP BY author_id
   HAVING count(*) > 1)
ORDER BY 1, 2;
```
The SELECT statement within the parenthesis is referred to as an "Inner Query".  
The SELECT statement that starts on the first line is referred to as the "Outer Query."  

With a subquery you can get results from a table using information from that same table...  
```
SELECT title, price
FROM book
WHERE price IN
  (SELECT DISTINCT price
   FROM book
   WHERE title LIKE 'How%')
ORDER BY 1, 2;
```

You can nest subquery statements.  For example, if I want to see which authors sell books that cost 12.99...  
```
SELECT lastname, firstname, 'sell books at 12.99'
FROM author
WHERE author_id IN
  (SELECT author_id
   FROM bookauthor
   WHERE isbn IN
     (SELECT isbn
      FROM book
      WHERE price = 12.99))
ORDER BY 1, 2;
```
### Subqueries using a comparison operator 
For most subqueries you use the IN operator to compare a column value to a list of column values brought back by another SELECT statement.  This type of comparison is always looking for equality.  

There is another type of subquery where you use a regular comparison operator (like =, >, <, etc.) instead of the IN operator.  

When you use a comparison operator, instead of an IN, the inner query MUST return exactly one single value  (i.e. one row, one cell) otherwise it is an error condition.  

How can you be absolutely sure you get one value returned from a SELECT statement?  

Use an aggregate function like AVG or SUM....  
```
SELECT title, price
FROM book
WHERE price >
  (SELECT AVG(price)
   FROM book)
ORDER BY 1;
```

Another Example...  
```
SELECT title, ytd_sales, price
FROM book
WHERE ytd_sales >
  (SELECT SUM(ytd_sales) - 30000
   FROM book
   WHERE price < 20)
ORDER BY 1, 2, 3;
```
You can use a subquery with the HAVING clause...  
```
SELECT type, SUM(ytd_sales)
FROM book
GROUP BY type
HAVING AVG(ytd_sales) >
  (SELECT AVG(ytd_sales)
   FROM book)
ORDER BY 1, 2;
```

### Subqueries Vs Joins  
Many subqueries could be written as JOINs, for example...  
```
SELECT title, 'is published by All Techo Books'
 FROM book
 WHERE pub_id IN
   (SELECT pub_id
    FROM publisher
    WHERE name = 'All Techo Books')
 ORDER BY 1;
```
... could be written as...  
```
SELECT name, title
FROM book JOIN publisher USING(pub_id)
WHERE name = 'All Techo Books'
ORDER BY 1;
```
It is often a judgement call on which one to use.  

For large sets of data, subqueries often run quicker since each SELECT statement is run individually.  

If you need to see information from more than one table, then you must use a JOIN... a subquery will only allow you to see columns from the outer query.  

Another advantage to using a subquery is that you can compare a detail value to an aggregate value (e.g. WHERE price = (SELECT AVG(price) FROM ...)  

Additionally, you can based the results of the outer query on results from the inner query using the same table.  

There is a way to do with this a self-join, as well, but that is generally more complex and harder to understand.  


### Using a subquery Vs Self-Join 
A Copy editor with an editor_id of 9 might be managed by the Managing editor with an editor_id of 5.  

Imagine, if you will, that the editor table includes another column, manager_editor_id, that holds the manager's editor_id.  

You could find the manager of a copy editor with a subquery like this...  

Here is a simple subquery...  
```
SELECT lastname, firstname
FROM editor
WHERE editor_id IN
  (SELECT manager_editor_id
   FROM editor
   WHERE editor_id = 3)
ORDER BY 1;
```
Notice that the inner query is using the same table as the outer query.  

To rewrite this as a "self-join" you must use different table aliases. This will "trick" SQL to think that there are two copies of the same table.  

So the subquery rewritten as a self-join would look something like this...  
```
SELECT e2.lastname, e2.firstname
FROM editor e1
  JOIN editor e2 ON (e1.editor_id = e2.managing_editor_id)
WHERE e1.editor_id = 3
ORDER BY 1, 2;
```

This is hard to visualize and always use a subquery instead!  

### How data is organized in a relational database 

One of the main reasons for storing and managing data in a relational database is to reduce data redundancy.  

The author's first and last name, for example, are stored in the author table.  The names are not stored again in the book table.  If we need to see the author names along  
with the book information you join the related tables to retrieve that information.  

The only data that is commonly (and necessarily) repeated is stored in Foreign Key columns.  This is what allows us to connect the information in the tables back together.  

So how do you design a relational database so that it follows these rules of non-redundancy? How do you know how to make connections between the tables?  

The first technique is called Entity-Relationship Modeling and the second technique is known as Normalization.  

You know that all data stored in a relational database is stored in a grid-like structure called a table. A table "looks like" a bit like a spreadsheet.  

When creating a relational database, the first thing you do is think about something called "Entities". An entity is a person, place, or thing you want to keep track of. For example, if you are a publishing company you want to keep track of books and authors.  

You have been working with a book table and an author table but before you get to the point of building tables, you need to start with the conceptual design involved with the author and book entities.  

The relationship between books and authors is Many-to-Many... one author can write one or more (i.e. many) books and one book can have one or more (i.e. many) authors.  

So, if you need to design a relational database, you gather the data you need to track (i.e. author's name, phone number, book titles, book type, etc.) and you then determine how to group the data into Entities.  
Then you determine what is the relationship between those Entities (e.g. One-to-Many, Many-to-Many.)  

Lastly, you apply the Normalization guidelines to reduce data redundancy.  

### The Entity-Relationship Approach

### Normalization Guidelines 

### Assignment 
1. Name some advantages and disadvantages to generating an "IN" list with another SELECT statement.
2. Use a subquery to find the books that are published by Sunshine Publishers.
3. Find all editors who have written books that were published.
4. Code a SELECT statement that shows a book title and ytd_sales for books whose ytd_sales is greater that the smallest value for zip code on the author table.  (Not useful, but fun.)
5. Code a SELECT statement to see which editors are getting paid the highest salary.
6. Take the following SELECT statement, that uses a join and rewrite it using a subquery.  
```
SELECT title, 'costs 12.99 and was written by Anne Singer'
FROM book
  JOIN bookauthor USING (ISBN)
  JOIN author USING(author_id)
WHERE price = 12.99 AND lastname = 'Singer' AND firstname = 'Anne'
ORDER BY 1;
```
7. 

