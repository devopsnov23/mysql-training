## Subqueries and Data Modelling 

### How do Subqueries work?

Using the IN operator a SELECT statement can be constructed to see if a column values matches what is in a specified list...  
```
SELECT lastname, firstname, state
FROM author
WHERE state IN ('IL', 'UT', 'MI')
ORDER BY 1, 2, 3;
```

The values in the list can be generated by another SELECT statement instead of keyed in directly to the statement.  

If I want to find all authors who live in states where a publisher is based I could first look up the distinct states in the publisher table, 'CA' and 'NY' and then use this...  
```
SELECT lastname, firstname, state
FROM author
WHERE state IN ('CA', 'NY')
ORDER BY 1, 2, 3;
```

...Or I could replace the list with another SELECT statement like so...  
```
SELECT lastname, firstname, state
FROM author
WHERE state IN
	(SELECT DISTINCT state FROM publisher)
ORDER BY 1, 2, 3;
```

The list of DISTINCT states in the publisher table could change (in the real world) if we added another publisher to the table from a different state.  

Conceptually, subqueries can be nested as deep as you want. In most cases, a subquery statement is processed from the bottom-up.  
The deepest nested SELECT statement sends values up to the next SELECT statement which again sends value up to the next SELECT, etc.  

It is important to remember that the values generated by a SQL statement must match the kind of value being compared to the left of the IN operator.  

This would be a mistake...  
```
SELECT lastname, firstname, state
FROM author
WHERE city IN
	(SELECT DISTINCT state FROM publisher)
ORDER BY 1, 2, 3;
```
Because I am comparing the city column to a generated list of states. This does not make logical sense.  

Also, you must compare one column to a list of values generated from one column.  

This would be a mistake...  
```
SELECT lastname, firstname, state
FROM author
WHERE city IN
	(SELECT city, state FROM publisher)
ORDER BY 1, 2, 3;
```

... because the inner query has generated a list of cities and states that the statement is comparing to city value alone.  

### Subqueries with the IN operator 
The IN operator will always compare the values for equality against value of the column specified.  

Here is how to generally format a subquery...
```
SELECT lastname, firstname, 'wrote more than one book'
FROM author
WHERE author_id IN
  (SELECT DISTINCT author_id
   FROM bookauthor
   GROUP BY author_id
   HAVING count(*) > 1)
ORDER BY 1, 2;
```
The SELECT statement within the parenthesis is referred to as an "Inner Query".  
The SELECT statement that starts on the first line is referred to as the "Outer Query."  

With a subquery you can get results from a table using information from that same table...  
```
SELECT title, price
FROM book
WHERE price IN
  (SELECT DISTINCT price
   FROM book
   WHERE title LIKE 'How%')
ORDER BY 1, 2;
```

You can nest subquery statements.  For example, if I want to see which authors sell books that cost 12.99...  
```
SELECT lastname, firstname, 'sell books at 12.99'
FROM author
WHERE author_id IN
  (SELECT author_id
   FROM bookauthor
   WHERE isbn IN
     (SELECT isbn
      FROM book
      WHERE price = 12.99))
ORDER BY 1, 2;
```
### Subqueries using a comparison operator 
For most subqueries you use the IN operator to compare a column value to a list of column values brought back by another SELECT statement.  This type of comparison is always looking for equality.  

There is another type of subquery where you use a regular comparison operator (like =, >, <, etc.) instead of the IN operator.  

When you use a comparison operator, instead of an IN, the inner query MUST return exactly one single value  (i.e. one row, one cell) otherwise it is an error condition.  

How can you be absolutely sure you get one value returned from a SELECT statement?  

Use an aggregate function like AVG or SUM....  
```
SELECT title, price
FROM book
WHERE price >
  (SELECT AVG(price)
   FROM book)
ORDER BY 1;
```

Another Example...  
```
SELECT title, ytd_sales, price
FROM book
WHERE ytd_sales >
  (SELECT SUM(ytd_sales) - 30000
   FROM book
   WHERE price < 20)
ORDER BY 1, 2, 3;
```
You can use a subquery with the HAVING clause...  
```
SELECT type, SUM(ytd_sales)
FROM book
GROUP BY type
HAVING AVG(ytd_sales) >
  (SELECT AVG(ytd_sales)
   FROM book)
ORDER BY 1, 2;
```

### Subqueries Vs Joins  
Many subqueries could be written as JOINs, for example...  
```
SELECT title, 'is published by All Techo Books'
 FROM book
 WHERE pub_id IN
   (SELECT pub_id
    FROM publisher
    WHERE name = 'All Techo Books')
 ORDER BY 1;
```
... could be written as...  
```
SELECT name, title
FROM book JOIN publisher USING(pub_id)
WHERE name = 'All Techo Books'
ORDER BY 1;
```
It is often a judgement call on which one to use.  

For large sets of data, subqueries often run quicker since each SELECT statement is run individually.  

If you need to see information from more than one table, then you must use a JOIN... a subquery will only allow you to see columns from the outer query.  

Another advantage to using a subquery is that you can compare a detail value to an aggregate value (e.g. WHERE price = (SELECT AVG(price) FROM ...)  

Additionally, you can based the results of the outer query on results from the inner query using the same table.  

There is a way to do with this a self-join, as well, but that is generally more complex and harder to understand.  


### Using a subquery Vs Self-Join 
A Copy editor with an editor_id of 9 might be managed by the Managing editor with an editor_id of 5.  

Imagine, if you will, that the editor table includes another column, manager_editor_id, that holds the manager's editor_id.  

You could find the manager of a copy editor with a subquery like this...  

Here is a simple subquery...  
```
SELECT lastname, firstname
FROM editor
WHERE editor_id IN
  (SELECT manager_editor_id
   FROM editor
   WHERE editor_id = 3)
ORDER BY 1;
```
Notice that the inner query is using the same table as the outer query.  

To rewrite this as a "self-join" you must use different table aliases. This will "trick" SQL to think that there are two copies of the same table.  

So the subquery rewritten as a self-join would look something like this...  
```
SELECT e2.lastname, e2.firstname
FROM editor e1
  JOIN editor e2 ON (e1.editor_id = e2.managing_editor_id)
WHERE e1.editor_id = 3
ORDER BY 1, 2;
```

This is hard to visualize and always use a subquery instead!  

### How data is organized in a relational database 

One of the main reasons for storing and managing data in a relational database is to reduce data redundancy.  

The author's first and last name, for example, are stored in the author table.  The names are not stored again in the book table. If we need to see the author names along with the book information you join the related tables to retrieve that information.  

The only data that is commonly (and necessarily) repeated is stored in Foreign Key columns.  This is what allows us to connect the information in the tables back together.  

So how do you design a relational database so that it follows these rules of non-redundancy? How do you know how to make connections between the tables?  

The first technique is called Entity-Relationship Modeling and the second technique is known as Normalization.  

You know that all data stored in a relational database is stored in a grid-like structure called a table. A table "looks like" a bit like a spreadsheet.  

When creating a relational database, the first thing you do is think about something called "Entities". An entity is a person, place, or thing you want to keep track of. For example, if you are a publishing company you want to keep track of books and authors.  

You have been working with a book table and an author table but before you get to the point of building tables, you need to start with the conceptual design involved with the author and book entities.  

The relationship between books and authors is Many-to-Many... one author can write one or more (i.e. many) books and one book can have one or more (i.e. many) authors.  

So, if you need to design a relational database, you gather the data you need to track (i.e. author's name, phone number, book titles, book type, etc.) and you then determine how to group the data into Entities.  
Then you determine what is the relationship between those Entities (e.g. One-to-Many, Many-to-Many.)  

Lastly, you apply the Normalization guidelines to reduce data redundancy.  

### The Entity-Relationship Approach

Entity-Relationship Modeling, or ER Modeling for short, is the process of identifying what persons, places, or things you are going track and discovering the relationships between those persons, places, or things.  

The persons, places, or things you identify are called "Entities".  Ultimately an entity will be used to help design and create an actual database table in the database.  

An entity (e.g. author) has attributes.  For example, an author has a firstname attribute, a lastname attribute, a phone number attribute, etc.  These attributes will be used to help define the columns that will go on the database table that will be built from the entity.  

When doing data analysis, you may begin grouping data into the entities and the attributes, however, with ER Modeling you will just concentrate on the entities themselves and their relationship to each other.  

Here is some data that a Real Estate company may want to track...  
	Houses  
	Agents  
	Clients  
	Sale Price  
	Offer Price  

What in the data list is an entity and what might be an attribute of an entity?  

House seems like an entity since it can have attributes like address, number of bedrooms, sale price, etc.  

Right away I notice that "sale price" is probably an attribute of House and not an entity itself.  

What about the agents? Would it be best to have separate entities for a Internal Agent and a External Agent? Or should Agent be the Entity and what type of agent they are would be an attribute?  

I will go with two separate entities and store the external clients with the external agent.  

So far I have four entities...  
  CLIENT  
  AGENT-INTERNAL  
  AGENT-EXTERNAL  
  HOUSE  

What are the relationships?  

**IMPORTANT:**  You should always use the singular when naming entities or tables, since the entity/table name describes the type of entities that will be held in the rows of the table.  Clearly there can be more than one row!  

A house can be bought by only one client, but a client could buy more than one house... so you have a ONE-TO-MANY from CLIENT to HOUSE  

What about offers on a house? A client could make more than one offer on a single house (or multiple houses) and a house could have more than one offer made on it by clients of ours, however, our agency has a rule that we will not represent more than one person at time to a particular house.. so we are not make our clients compete with each other.  

So now the relationship between CLIENT and HOUSE still is a ONE-TO-MANY... from our perspective.  

What is the relationship of AGENT-INTERNAL to HOUSE?  

An internal agent can sell (or list) more than one house but a house can only be represented by one agent (in our agency.)  

Remember that I am modeling data for a single real estate agency.  The data I track only needs to reflect my agency's information... not all possible realities from a client or outside agents point of view.  

An external agent can list/sell more than one house (to us) and house can be listed/sold by more than one external agent.  

One advantage to having separate entities is we can track more information about our own employees (internal agents.)  

An internal agent can have more than one client, but a client will have only one agent (of ours.)  

An external agent may have more than one client (that they are representing to us) and, theoretically, that agent's client could be represented to us by different agents concerning different houses... but, since we are tying external clients directly to their external agents (in our database) we will not try to track external clients as unique entities.  

For example, if Joe Smith is represented by Sally Jones on House 1 and Joe Smith is represented by Sam Mathers on House 2... as far as our database is concerned, Joe Smith is two different people!   It simply is not our concern to track external clients except as they relate to a particular house that we represent.  

We do not need to track what an external agent is up to with his/her clients... except how it relates to our agency.  

### Normalization Guidelines 

Normalization is a funny word.  

It means to "normalize" the data, which is a fancy way of saying we are going to continue organizing the data so that data redundancy is greatly reduced.  

This process is most often done after the ER modeling is completed.  

The normalization guidelines are rules we can apply to the entities that may result in breaking up some entities, that seemed to make sense to stay together, into smaller entities that will reduce data redundancy.  

As we go through this process of normalization, each step will bring the entity (or table) into various "forms". These normalization forms describe the state that the entity (or table) is in, according to the normalization rules that have been applied to them.  

It seems a bit strange now but it will become clearer as you learn these normalization rules.  

When you apply the first set of normalization rules the entity (or table) will be said to be in "First Normal Form."  

When you apply the second set of normalization rules the entity (or table) will be said to be in "Second Normal Form."  

When you apply the third set of normalization rules the entity (or table) will be said to be in "Third Normal Form."  

Fortunately, this is usually where you stop the process.  

While there are other Normal Forms defined, the goal of most data modelers is to bring the database into Third Normal Form.  

A database is said to be in Third Normal Form when all of its tables are (at least) in Third Normal Form.  

**NOTE:** In this presentation, I am going to give you a practical definition of the Normal Forms. This means I have simplified the definitions so you don't have to deal with academic terms.

**First Normal Form**

A table is in First Normal Form when the data in each column could not be reasonably broken down further into smaller pieces and there are no repeating groups.  

A repeating group, for example, is something like pet 1, pet 2, pet 3, etc.  if I was keeping track of how many pets someone had.  

Fortunately, there is something that you can do to remove a repeating group from a table and put it in first normal form correctly.  

Let's look at tables as we have it so far:  

CLIENT (name, address, phone, house, offer_1, offer_2, offer_3)  
HOUSE (address, listing price, sold price)  
AGENT-INTERNAL (name, years with agency)  
AGENT-EXTERNAL (name, agency, external_client1, external_client2, etc.)  

So we first need Primary Keys on the tables...  

CLIENT (client_id-PK, name, address, phone, house, offer_1, offer_2, offer_3)  
HOUSE (house_id-PK, address, listing price, sold price)  
AGENT-INTERNAL (agent_id-PK, name, years with agency, house_1, house_2, etc.)  
AGENT-EXTERNAL (ext_agent_id-PK, name, agency, ext_client1, ext_client2, etc.)  

NOTE:  This format of listing table/entity names, then listing the columns/attributes in parentheses is known as Relational Notation.  

Remove repeating groups...  

CLIENT (client_id-PK, name, address, phone)  
HOUSE (house_id-PK, address, listing price, sold price)  
OFFER (client_id-PK, house_id-PK, offer_date-PK, offer, client name)  
AGENT-INTERNAL (agent_id-PK, name, years with agency)  
AGENT_INT_HOUSE (agent_id-PK-FK, house_id-PK-FK, agent name)  
AGENT-INT_CLIENT (agent_id-PK-FK, client_id-PK-FK, last_name, first_name  
AGENT-EXTERNAL (ext_agent_id-PK, name, agency)  
AGENT-EXT_CLIENT (ext_agent_id-PK-FK, ext_client-PK-FK, house_id-PK-FK)  

Break the data into smallest reasonable parts...  

CLIENT (client_id-PK, first_name, last_name, street, city, state, zip, phone)  
HOUSE (house_id-PK, street, city, state, zip, listing price, sold price)  
OFFER (client_id-PK, house_id-PK, offer_date-PK, offer, last_name, first_name, street, city, state, zip)  
AGENT-INTERNAL (agent_id-PK, last_name, first_name, years with agency)  
AGENT_INT_HOUSE (agent_id-PK-FK, house,_id-PK-FK, last_name, first_name)  
AGENT-INT_CLIENT (agent_id-PK-FK, client_id-PK-FK, last_name, first_name)  
AGENT-EXTERNAL (ext_agent_id-PK, last_name, first_name, agency)  
AGENT-EXT_CLIENT (ext_agent_id-PK-FK, ext_client-PK-FK, house_id-PK-FK)  

**Second Normal Form**

In order to be in Second Normal Form, a table must be in First Normal Form and no non-key column must be derived from another non-key column.  

Remove non-key dependencies (address info...)  

CLIENT (client_id-PK, first_name, last_name, street, city, state, zip, phone)  
HOUSE (house_id-PK, street, city, state, zip, listing price, sold price)  
OFFER (client_id-PK, house_id-PK, offer_date-PK, offer, last_name, first_name)  
AGENT-INTERNAL (agent_id-PK, last_name, first_name, years with agency)  
AGENT_INT_HOUSE (agent_id-PK-FK, house,_id-PK-FK, last_name, first_name)  
AGENT-INT_CLIENT (agent_id-PK-FK, client_id-PK-FK, last_name, first_name)  
AGENT-EXTERNAL (ext_agent_id-PK, last_name, first_name, agency)  
AGENT-EXT_CLIENT (ext_agent_id-PK-FK, ext_client-PK-FK, house_id-PK-FK)  

**Third Normal Form**

In order to be in Third Normal Form, a table must be in Second Normal Form and all columns are fully dependent on the entire Primary Key.  

Removing lastname, firstname...  

CLIENT (client_id-PK, first_name, last_name, street, city, state, zip, phone)  
HOUSE (house_id-PK, street, city, state, zip, listing price, sold price)  
OFFER (client_id-PK, house_id-PK, offer_date-PK, offer)  
AGENT-INTERNAL (agent_id-PK, last_name, first_name, years with agency)  
AGENT_INT_HOUSE (agent_id-PK-FK, house,_id-PK-FK)  
AGENT-INT_CLIENT (agent_id-PK-FK, client_id-PK-FK)  
AGENT-EXTERNAL (ext_agent_id-PK, last_name, first_name, agency)  
AGENT-EXT_CLIENT (ext_agent_id-PK-FK, ext_client-PK-FK, house_id-PK-FK)  

Are there any other relationships, attributes?  

CLIENT (client_id-PK, first_name, last_name, street, city, state, zip, phone)  
HOUSE (house_id-PK, street, city, state, zip, listing price, sold price)  
OFFER (client_id-PK, house_id-PK, offer_date-PK, offer, accepted_yn)  
AGENT-INTERNAL (agent_id-PK, last_name, first_name, years with agency)  
AGENT_INT_HOUSE (agent_id-PK-FK, house,_id-PK-FK, date_assigned)  
AGENT-INT_CLIENT (agent_id-PK-FK, client_id-PK-FK, date_contracted)  
AGENT-EXTERNAL (ext_agent_id-PK, last_name, first_name, agency)  
AGENT-EXT_CLIENT (ext_agent_id-PK-FK, ext_client_id-PK-FK, house_id-PK-FK)  

An easy way to remember if a table is in third normal form is...  
A table is in third normal form if every non-key column is dependent on the key, the whole key, and nothing but the key  


### Assignment 
1. Name some advantages and disadvantages to generating an "IN" list with another SELECT statement.
2. Use a subquery to find the books that are published by Sunshine Publishers.
3. Find all editors who have written books that were published.
4. Code a SELECT statement that shows a book title and ytd_sales for books whose ytd_sales is greater that the smallest value for zip code on the author table.  (Not useful, but fun.)
5. Code a SELECT statement to see which editors are getting paid the highest salary.
6. Take the following SELECT statement, that uses a join and rewrite it using a subquery.  
```
SELECT title, 'costs 12.99 and was written by Anne Singer'
FROM book
  JOIN bookauthor USING (ISBN)
  JOIN author USING(author_id)
WHERE price = 12.99 AND lastname = 'Singer' AND firstname = 'Anne'
ORDER BY 1;
```
7. Think about organizations or companies you have worked for.   What kind of data was being tracked?   What kind of entities do you think were used in the design of the database (e.g. Employee, Department, etc.)


